## 解説
```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
  int N;
  vector<int> A(N);
  for(auto& i:A){cin >> i;}

  auto b = A;
  sort(b.begin(), b.end());
  int ans = b[N - 2];

  for (int i = 0;i < N;i++) {
    if (A[i] == ans) {
      cout << i + 1 << endl;
    }
  }

  return 0;

}
```
## 解説

このプログラムは「**与えられた数列の中で 2 番目に大きい値を見つけ、その値を持つ要素の位置（インデックス）を出力する**」処理をしています。

---

## ステップごとの解説

### 1. 入力の受け取り

```cpp
int N;
cin >> N;
vector<int> A(N);
for(auto &i : A) cin >> i;
```

* `n` を入力（配列の要素数）。
* `vector<int> A(N)` で長さ `N` の整数配列 `A` を用意。
* `for(auto &i : A)` で配列 `A` に値を入力。

---

### 2. 配列をコピーしてソート

```cpp
auto b = A;
sort(b.begin(), b.end());
```

* `A` を `b` にコピー。
* `b` を昇順にソート。

例：`A = [10, 30, 20, 50]` → `b = [10, 20, 30, 50]`

---

### 3. 2番目に大きい値を取得

```cpp
int ans = b[N - 2];
```

* ソート済み配列 `b` の末尾は最大値。
* その1つ前 `b[n-2]` が 2番目に大きい値。

例：`b = [10, 20, 30, 50]` → `ans = b[2] = 30`

---

### 4. 元の配列で位置を探す

```cpp
for(int i = 0; i < N; i++) {
    if(A[i] == ans) {
        cout << i + 1 << endl;
    }
}
```

* 元の配列 `a` を走査。
* `tar`（2番目に大きい値）と等しい要素を見つけたら、その **位置 (1-based index)** を出力。

例：
`A = [10, 30, 20, 50]`, `ans = 30`
→ `A[1] = 30` なので `i+1 = 2` を出力。

---

## 出力例

入力:

```
4
10 30 20 50
```

処理:

* 最大値 = 50
* 2番目に大きい値 = 30
* その位置 = 2

出力:

```
2
```

---

## まとめ

このコードは

1. 配列をコピーしてソート
2. 2番目に大きい値を特定
3. 元の配列の中でその値がある位置を出力

という流れになっています。


