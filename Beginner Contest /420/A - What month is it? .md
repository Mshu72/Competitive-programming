## 解答
```C++
#include<bits/stdc++.h>
using namespace std;

int main() {
  int X, Y;
  cin >> X >> Y;

  int ans = (X + Y -1) % 12 + 1;

  cout << ans << endl;
  return 0;
}
```
## 解説
### `(X + Y -1) % 12 + 1`となる理由
ポイントは「結果を **1〜12** の範囲で表したい」からです。

### なぜ `-1` してから `%12` するの？

`%`（剰余）は本来 **0〜11** の世界（0始まり）でうまく回ります。
でも「時計の針」や「月」のように **1〜12** で回したいとき、そのまま `(X+Y)%12` だと **12のときに 0 になってしまう** のが困ります。

そこで

1. **1始まり → 0始まり** にずらす（`X-1`）
2. そこで足し算して `%12`
3. **0始まり → 1始まり** に戻す（最後に `+1`）

という変換をまとめたのが
`(X + Y - 1) % 12 + 1` です。

### 具体例

* `X=7, Y=5`（7時に5時間後）

  * 素朴に `(7+5)%12 = 0` → でも答えは **12時** にしたい
  * `((7+5)-1)%12 + 1 = 11%12 + 1 = 11 + 1 = 12` ✅
* `X=11, Y=2`

  * `((11+2)-1)%12 + 1 = 12%12 + 1 = 0 + 1 = 1` → **1時** ✅

### まとめ（1-indexed の剰余）

「1〜12で循環させたい」＝ **1-indexed modulo** を使う

$$
\text{ans} = ((X + Y - 1) \bmod 12) + 1
$$

です。
もし **0〜11** でよい（0時を許す）なら、普通に `(X+Y)%12` でOK。

※ もし `Y` が負（逆方向に戻す）もあり得るなら、C++ の `%` は負値でマイナスになるので、

```cpp
int ans = (( (X - 1 + Y) % 12 + 12 ) % 12) + 1;
```

のように二重に補正すると常に 1〜12 に収まります。
