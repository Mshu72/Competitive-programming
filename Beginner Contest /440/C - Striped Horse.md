## 問題の本質的な読み替え

* マスは **1～N**
* 全部白からスタート
* 操作は **1回だけ**
* 正整数 `x` を1つ選ぶ
* 条件
  [
  (i + x) \bmod (2W) < W
  ]
  を満たす `i` を **すべて黒く塗る**
* マス `i` を黒くするとコスト `C[i]`

→ **x をどう選ぶかで、黒くなるマス集合が決まる**

---

## 条件の意味を整理する

### `(i + x) mod (2W) < W` とは？

* 長さ `2W` の周期
* そのうち **前半 W 個だけ黒くなる**

つまり：

* 周期 `2W`
* その中で **連続 W 個が黒**
* `x` は「その黒区間の開始位置をずらす量」

---

## 視点を変える（重要）

### i を固定して考える

マス `i` が黒くなるのは：


x = [-i, -i+W-1] (mod{2W})


つまり：

* 各マス `i` は
* **x の取りうる区間（長さ W）** を1つ持っている
* その区間に x が入ると、`i` は黒くなる

---

## 問題の言い換え（核心）

* x は `0 ～ 2W-1` のどれか
* 各 `i` は

  * 「x がこの区間に入ったらコスト `C[i]` を払う」
* **x を1つ選んだときの総コストを最小化せよ**

→　**円環（mod 2W）上の区間加算問題**

---

## 解法の基本方針

### 1️⃣ 差分配列（imos法）を使う

* 配列 `cost[0 … 2W-1]` を用意
* 各マス `i` について：

  * 有効な x の区間 `[L, R]` を求める
  * その区間に `C[i]` を加算

※ 区間が **mod 2W で折り返す**場合があるので注意

---

### 2️⃣ 区間処理の具体例

* 区間が普通に収まる場合

  ```
  cost[L] += C[i]
  cost[R+1] -= C[i]
  ```
* 区間が円環をまたぐ場合

  ```
  cost[L] += C[i]
  cost[2W] -= C[i]
  cost[0] += C[i]
  cost[R+1] -= C[i]
  ```

---

### 3️⃣ 累積和を取る

* `cost` の累積和を取ると
* 各 `x` に対する **総コスト** が分かる

---

### 4️⃣ 最小値を探す

* `x = 0 ～ 2W-1` を全探索
* 最小の累積コストが答え

---

## 計算量

* 各マスごとに **O(1)** で区間処理
* 累積和と最小探索：**O(W)**
* 全体：
  [
  O(N + W)
  ]

→ **T 個のテストケースでも十分高速**

---

## C++実装時の注意点

* `2W` は最大サイズに注意（long long）
* `mod` 演算で負になる場合は

  ```cpp
  (x % mod + mod) % mod
  ```
* 差分配列は `vector<long long>`

---

## まとめ（解答方針の一文要約）

> 各マスが「x に対してコストが発生する区間」を持つと考え、
> 円環上の区間加算を差分配列で処理し、
> 累積和の最小値を求める。

# 解答例
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;

    while (T--) {
        int N;
        ll W;
        cin >> N >> W;

        vector<ll> C(N);
        for (int i = 0; i < N; i++) {
            cin >> C[i];
        }

        ll M = 2 * W;
        vector<ll> diff(M + 1, 0); // 差分配列

        for (int i = 0; i < N; i++) {
            // x ≡ [-i, -i+W-1] (mod 2W)
            ll L = (-i % M + M) % M;
            ll R = (-i + W - 1) % M;
            if (R < 0) R += M;

            if (L <= R) {
                // 区間がそのまま収まる
                diff[L] += C[i];
                diff[R + 1] -= C[i];
            } else {
                // 円環をまたぐ
                diff[L] += C[i];
                diff[M] -= C[i];
                diff[0] += C[i];
                diff[R + 1] -= C[i];
            }
        }

        // 累積和を取り、最小値を探す
        ll ans = LLONG_MAX;
        ll cur = 0;
        for (int x = 0; x < M; x++) {
            cur += diff[x];
            ans = min(ans, cur);
        }

        cout << ans << '\n';
    }

    return 0;
}
```
