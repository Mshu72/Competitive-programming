## 解答例
```cpp
#include <bits/stdc++.h>
using namespace std;
char s[1000010];
int main(){
  long long n,sum=0,sum2=0,x=0;
  cin>>n;
  scanf("%s",s+1);
  for(long long i=1;i<=2*n;i++)
    if(s[i]=='B'){
      x++;
      sum+=abs(2*x-1-i);
      sum2+=abs(2*x-i);
    }
   cout<<min(sum,sum2);
}
```
## 解説
ざっくり言うとこのコードは、文字列中の **'B' を交互配置（B が奇数番 or 偶数番のどちらか）** に並べ替えるために必要な**最小の隣接スワップ回数**を計算しています。その結果として `min(sum, sum2)` を出力しています。

---

## 何を読んでいる？

* `n` を読み取り、その後に **長さ `2*n` の文字列** `s` を読みます（`s+1` に入れているので **1 から 2n の添字**でアクセスします）。
* 例：`n=3` なら文字列は長さ 6（`i=1..6`）。

> ※ `cin >> n;` の後に `scanf("%s", s+1);` と **C++ と C の入出力を混ぜて**います。動作はしますが、初心者なら `string` で `cin >> s;` と揃えるほうが自然です（下に改善案あり）。

```cpp
scanf("%s", s+1);
```

### 何をしているか？

* `scanf("%s", …)` は **文字列（C言語形式の文字配列）を読み込む** 関数。
* `s+1` は「配列 `s` の先頭から 1 つ進んだ場所」を意味します。
  → つまり **文字列を `s[1]` から格納**します。

### なぜ `s+1` なのか？

* C の文字列は普通 `s[0]` から格納しますが、このコードでは **1 から始まる添字（1-index）で処理したい**ため、意図的に `s[1]` から読み込みます。
* その結果：

  * 文字列 `"ABC"` を入力すると
    `s[1]='A'`, `s[2]='B'`, `s[3]='C'`, `s[4]='\0'`（終端文字）
  * `s[0]` は空いたまま（未使用）。

### ポイント

* `s+1` は **「配列の番地に +1」** しているだけ。C++ のポインタ演算。
* 添字を 1 から扱いたいときのテクニック。

---

## 変数の意味

* `x`: 左から読んだとき、**いま見つけた 'B' が何個目の 'B' か**（1,2,3,…）を数えるカウンタ。
* `sum`: 「**B をすべて奇数番（1,3,5, …）に並べたい**」としたときの、必要スワップ数の合計。
* `sum2`: 「**B をすべて偶数番（2,4,6, …）に並べたい**」としたときの、必要スワップ数の合計。

---

## なぜこの式？

ループでは `i = 1..2n` を走らせ、`s[i]=='B'` なら

```cpp
x++; // 何個目のBか（k番目のB）
sum  += abs( (2*x - 1) - i ); // 奇数番配置なら、k番目のBの目標位置は 2k-1
sum2 += abs( (2*x)     - i ); // 偶数番配置なら、k番目のBの目標位置は 2k
```

* **k 番目の 'B' の理想位置**

  * 奇数番に詰めるなら → `2k-1`
  * 偶数番に詰めるなら → `2k`
* その 'B' の現在位置は `i`。
  **隣接スワップの最小回数**は「今の位置から理想位置までの距離」＝`|目標位置 - i|`。
  それを **すべての 'B' で足し合わせる**と、必要最小スワップ数になります。
* どちら（奇数or偶数）に詰めるのが得かはケース次第なので、最後に `min(sum, sum2)` を出します。

> 直感：'B' 以外（'W' など）を挟んで左/右へひとつ動かすたびに隣接スワップ1回なので、距離の総和＝最小スワップ回数になります。

---

## 小さな例で追ってみる

`n=3, s="WBBWBW"`（1-indexで `i=1..6`）

* `i=2` の 'B' は 1個目のB（`x=1`）。

  * 奇数狙いの理想位置 `2*1-1=1` → 距離 `|1-2|=1`
  * 偶数狙いの理想位置 `2*1=2` → 距離 `|2-2|=0`
* …と全 'B' で合計し、`sum`（奇数詰め）と `sum2`（偶数詰め）を比較して小さい方を答えます。

---
```cpp
abs(2*x - 1 - i);
```

### 何をしているか？

* `abs(…)` は **絶対値を取る関数**（負数なら正に直す）。
* この式の中身は

  ```
  (2*x - 1) - i
  ```
* ここでの意味：

  * `x` = 今まで見つけた `'B'` の個数（今回のBが何個目か）。
  * `2*x - 1` = 「x 個目の 'B' が並ぶべき理想の位置（奇数番目 1,3,5,…）」。
  * `i` = 実際にその 'B' が出現した位置。

### つまり

* `(2*x - 1) - i` = 「理想位置 － 実際の位置」。
* それを `abs` で正に直す → **理想位置まで何歩動かせばよいか** を表す。

### 例

* 1 個目の 'B' (`x=1`) が `i=2` にあった場合：

  ```
  abs(2*1 - 1 - 2) = abs(1 - 2) = 1
  ```

  → 本来は位置 1 にあってほしいのに、2 にいるので **1 回動かせば良い**。
---

## ありがちなハマり所

* **入力は必ず長さ `2*n`** であること（このコードはそう仮定）。
* **'B' の数は問題設定上、だいたい n 個**（交互にしたいので）。コード自体は n 個でなくても計算はしますが、想定外の設定だと「完全交互」にはなりません。
* **1-indexで文字列を使っている**（`s+1` で読んで `i=1..2n` で回す）。慣れないと添字のズレに注意。
* **`cin` と `scanf` の混在**は避けるのが無難。

---

## 初学者向けの書き換え（0-index & string で素直に）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    long long n;
    cin >> n;

    string s;
    cin >> s;                 // s.size() は 2*n を想定
    long long x = 0, sum = 0, sum2 = 0;

    // i は 0..2n-1 だが、式は 1-index で考えやすいので pos = i+1 を使う
    for (long long i = 0; i < 2*n; ++i) {
        if (s[i] == 'B') {
            ++x;                       // これは k（左からk個目のB）
            long long pos = i + 1;    // 1-index に直す
            sum  += llabs((2*x - 1) - pos); // 奇数番 1,3,5,... へ
            sum2 += llabs((2*x)     - pos); // 偶数番 2,4,6,... へ
        }
    }
    cout << min(sum, sum2) << '\n';
}
```

* これなら **入出力は `cin/cout` で統一**、**0-index で安全**に書けます。
* 計算量は **O(2n)**、メモリも O(1) でシンプルです。







